<!DOCTYPE html>
<html lang="lv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dynamic Wallet Visualizer — Sepolia NFT Access</title>

  <!-- Font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />

  <!-- NOTE: If you can provide SRI hashes for the below scripts, add integrity="sha384-..." and keep crossorigin. -->
  <style>
    :root {
      --bg: #000;
      --muted: #9fb0c3;
      --accentFrom: #4a90e2;
      --accentTo: #9013fe;
      --glass: rgba(255,255,255,0.03);
      --success: #0ff;
    }

    @media (prefers-reduced-motion: reduce) {
      button, #fullscreenIcon, #toggleInfoIcon { transition: none !important; animation: none !important; }
    }

    body { font-family:'Inter',Arial,sans-serif; background:var(--bg); color:#fff; margin:0; padding:20px; position: relative; }
    .container { max-width:1400px; margin:auto; display:flex; flex-direction:column; align-items:center; gap:12px; }
    h1 { font-size:36px; margin:0; line-height:1; background:linear-gradient(90deg,#ffffff,#aaaaaa); -webkit-background-clip:text; -webkit-text-fill-color:transparent; text-align:center; }
    .subtitle { margin-top:4px; color:var(--muted); font-size:18px; text-align:center; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
    button { padding:12px 20px; border-radius:12px; border:none; cursor:pointer; background:linear-gradient(90deg,var(--accentFrom),var(--accentTo)); color:#fff; font-weight:700; font-size:16px; box-shadow:0 6px 18px rgba(0,0,0,0.45); transition: transform 0.2s, box-shadow 0.2s; }
    button:disabled { background:#444; cursor:not-allowed; box-shadow:0 6px 18px rgba(0,0,0,0.2); }
    button:hover:not(:disabled) { transform:translateY(-4px) scale(1.03); box-shadow:0 8px 22px rgba(0,0,0,0.65); }
    .snapshot-container { width:100%; background:var(--bg); border-radius:14px; padding:18px; box-shadow:0 12px 40px rgba(0,0,0,0.6); position:relative; }
    #snapshotCanvas { width:100%; border-radius:10px; border:1px solid var(--glass); display:block; margin-bottom:12px; background:transparent; }
    #recordTimer { margin-top:6px; color:var(--success); font-weight:600; font-size:16px; text-align:center; }
    #statusContainer { position: relative; width: 100%; height: 40px; margin-top: 8px; }
    .status { font-weight:600; font-size:16px; color:#fff; line-height:40px; text-align:center; }
    #progressBarContainer { position: absolute; top: 50%; left: 50%; width: 60%; height: 18px; background: rgba(255,255,255,0.1); border-radius: 6px; transform: translate(-50%, -50%); display: none; overflow: hidden; }
    #progressBar { height: 100%; width: 100%; background: linear-gradient(90deg,var(--success),var(--accentFrom)); border-radius: 6px; transform: scaleX(0); transform-origin: left center; transition: transform 0.4s ease; }
    #overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:999; }
    #recordDropdown { display:none; position: fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#111; border:2px solid #555; border-radius:12px; padding:80px 20px 20px 20px; z-index:1000; min-width:360px; box-shadow:0 8px 24px rgba(0,0,0,0.7); text-align:center; overflow-y:auto; }
    #recordDropdown button { width:100%; margin:16px 0; }
    #dropdownClose { position:absolute; top:10px; right:10px; cursor:pointer; font-size:28px; font-weight:bold; color:#fff; background:none; border:none; padding:0; line-height:1; }
    #fullscreenIcon { position:absolute; top:10px; right:10px; display:flex; align-items:center; cursor:pointer; color:var(--success); background:rgba(0,0,0,0.3); border-radius:6px; padding:6px 10px; transition: background 0.2s, transform 0.2s; z-index:10; user-select:none; }
    #fullscreenIcon:hover { background:rgba(0,255,255,0.2); transform: scale(1.05); }
    #fullscreenText { font-family:'Inter',Arial,sans-serif; white-space: nowrap; margin-left:6px; font-size:16px; font-weight:600; }
    #toggleInfoIcon { position:absolute; top:10px; left:10px; display:flex; align-items:center; cursor:pointer; color:var(--success); background:rgba(0,0,0,0.3); border-radius:6px; padding:6px 10px; transition: background 0.2s, transform 0.2s; z-index:10; user-select:none; }
    #toggleInfoIcon:hover { background:rgba(0,255,255,0.2); transform: scale(1.05); }
    #infoText { font-family:'Inter',Arial,sans-serif; white-space: nowrap; margin-left:6px; font-size:16px; font-weight:600; }
    #accountDisplay { width:100%; word-break:break-word; margin-top:8px; font-size:16px; text-align:center; }

    #tokenListContainer {
      display:none;
      position:absolute;
      top:80px;
      left:10px;
      max-height:150px;
      width:90%;
      max-width:576px;
      background:rgba(0,0,0,0.5);
      border-radius:9px;
      overflow-y:auto;
      padding:10px;
      color:#fff;
      font-family:'Inter',Arial,sans-serif;
      font-size:14px;
      z-index:15;
    }
    #tokenListContainer table { width:100%; border-collapse:collapse; }
    #tokenListContainer th, #tokenListContainer td { padding:6px 8px; text-align:left; font-size:13px; }
    #tokenListContainer th { color:var(--success); font-weight:600; }
    #tokenListContainer tr:nth-child(even) td { background:rgba(255,255,255,0.05); }
    #tokenListContainer tr:nth-child(odd) td { background:rgba(255,255,255,0.02); }
    #tokenListContainer::-webkit-scrollbar { width:6px; }
    #tokenListContainer::-webkit-scrollbar-thumb { background:var(--success); border-radius:3px; }
    #tokenListContainer::-webkit-scrollbar-track { background:#222; border-radius:3px; }

    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
    .toast { position: fixed; right: 20px; bottom: 20px; background: rgba(0,0,0,0.85); color: #fff; padding: 12px 16px; border-radius: 8px; z-index:2000; box-shadow: 0 6px 20px rgba(0,0,0,0.6); }
  </style>
</head>

<body>
  <a class="sr-only" href="#mainContent" id="skipLink">Sākt ar saturu</a>

  <div class="container" id="mainContent" role="main" aria-labelledby="appTitle">
    <header>
      <h1 id="appTitle">Dynamic Wallet Visualizer</h1>
      <p class="subtitle">Watch your Ethereum assets come alive — Sepolia NFT Access</p>
    </header>

    <section class="controls" aria-label="Controls">
      <button id="connectBtn">Connect Wallet</button>
      <button id="renderBtn" disabled aria-disabled="true">Render Snapshot</button>
      <button id="recordBtn" disabled aria-disabled="true" aria-haspopup="dialog" aria-expanded="false">Record 20s HD Video</button>
    </section>

    <div id="accountDisplay" aria-live="polite">Connected account: —</div>
    <div id="statusContainer" aria-hidden="false">
      <div id="statusMsg" class="status" role="status" aria-live="polite"></div>
      <div id="progressBarContainer" aria-hidden="true"><div id="progressBar" role="progressbar" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0"></div></div>
    </div>
    <div id="recordTimer" aria-live="polite">Recording: 0 / 20 s</div>

    <section class="snapshot-container" aria-label="Snapshot">
      <canvas id="snapshotCanvas" width="1920" height="1080" aria-label="Visualization canvas"></canvas>
      <div id="fullscreenIcon" role="button" tabindex="0" aria-label="Toggle fullscreen">⤢ <span id="fullscreenText">Fullscreen</span></div>
      <div id="toggleInfoIcon" role="button" tabindex="0" aria-pressed="true" aria-label="Toggle info">ℹ <span id="infoText">Info</span></div>

      <div id="tokenListContainer" aria-hidden="true">
        <table>
          <thead><tr><th>Address</th><th>Balance</th></tr></thead>
          <tbody id="tokenListContent"></tbody>
        </table>
      </div>
    </section>
  </div>

  <div id="overlay" tabindex="-1" aria-hidden="true"></div>

  <div id="recordDropdown" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="recordDialogTitle">
    <button id="dropdownClose" aria-label="Close">&times;</button>
    <h2 id="recordDialogTitle" class="sr-only">Record options</h2>
    <button id="recordWithTokensBtn">Record video with token list</button>
    <button id="recordWithoutTokensBtn">Record video without token list</button>
  </div>

  <!-- External libs (add integrity attributes if you have the SRI hashes) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js" crossorigin="anonymous"></script>

  <script>
    // ====== Configuration & safety notes ======
    // IMPORTANT: Never ship sensitive API keys in front-end code.
    // If you deploy, set providerRpcUrl server-side and only expose through a secure endpoint or env injection in build.
    const NFT_CONTRACT = "0x1EF02c3Ed33a98c10F0bf1fd71e4D226e8e408A5";
    const providerRpcUrl = "https://eth-sepolia.g.alchemy.com/v2/YOUR_ALCHEMY_KEY"; // placeholder — DO NOT use in production

    // ====== Elements ======
    const connectBtn = document.getElementById('connectBtn');
    const renderBtn = document.getElementById('renderBtn');
    const recordBtn = document.getElementById('recordBtn');
    const accountDisplay = document.getElementById('accountDisplay');
    const recordTimer = document.getElementById('recordTimer');
    const statusMsg = document.getElementById('statusMsg');
    const overlay = document.getElementById('overlay');
    const recordDropdown = document.getElementById('recordDropdown');
    const dropdownClose = document.getElementById('dropdownClose');
    const recordWithTokensBtn = document.getElementById('recordWithTokensBtn');
    const recordWithoutTokensBtn = document.getElementById('recordWithoutTokensBtn');
    const fullscreenIcon = document.getElementById('fullscreenIcon');
    const toggleInfoIcon = document.getElementById('toggleInfoIcon');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const progressBar = document.getElementById('progressBar');
    const tokenListContainer = document.getElementById('tokenListContainer');
    const tokenListContent = document.getElementById('tokenListContent');

    const canvas = document.getElementById('snapshotCanvas');
    const ctx = canvas.getContext('2d');
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);

    // ====== State ======
    let provider, signer, account, wcProvider;
    let showInfo = true;
    let tokens = [], ethBalance = 0, txCount = 0, particles = [], initialParticles = [], animRequest = null;
    let walletSeed = 0;

    // ====== Utilities ======
    function showProgressSmooth(){ progressBarContainer.style.display='block'; progressBar.style.transform='scaleX(0)'; progressBar.setAttribute('aria-hidden','false'); }
    function hideProgressSmooth(){ progressBar.style.transform='scaleX(1)'; progressBar.setAttribute('aria-hidden','true'); setTimeout(()=>{progressBarContainer.style.display='none'; progressBar.style.transform='scaleX(0)';},500); }

    function setStatus(text, isError=false){
      statusMsg.textContent = text || '';
      if(isError){ statusMsg.setAttribute('role','alert'); } else { statusMsg.setAttribute('role','status'); }
    }

    function showToast(msg, timeout=4000){
      const t = document.createElement('div'); t.className='toast'; t.textContent = msg;
      document.body.appendChild(t);
      setTimeout(()=>{ t.style.opacity = '0'; setTimeout(()=>t.remove(),300); }, timeout);
    }

    function hashStringToInt(str,mod=1000){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=Math.imul(h,16777619)>>>0;} return h%mod; }
    function seededRandomFloat(seedStr){ return hashStringToInt(seedStr,10000)/10000; }

    // Safe JSON parse (returns {} on invalid JSON)
    async function safeJson(res){
      try{
        const text = await res.text();
        return text ? JSON.parse(text) : {};
      }catch(e){
        console.error('Invalid JSON from API', e);
        return {};
      }
    }

    // ====== Canvas resizing ======
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const scale = isMobile ? 0.6 : 1;
      canvas.width = Math.round(1920*dpr*scale);
      canvas.height = Math.round(1080*dpr*scale);
      canvas.style.width = '100%';
      canvas.style.height = 'auto';
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr*scale, dpr*scale);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ====== Particles (unchanged big-O drawing logic as requested) ======
    async function initParticlesOnce(){
      initialParticles=[];
      const particleCount = Math.min(150,50+(tokens.length||0)*15);
      const seedBase = (account||'')+String(ethBalance)+String(txCount);
      for(let i=0;i<particleCount;i++){
        const t = tokens.length ? tokens[i%tokens.length] : {balance:1,address:String(i),symbol:'T'};
        const balanceFactor = t.isNFT ? 1 : Math.min(t.balance||0,20)/20;
        let hue = hashStringToInt((t.address||'')+seedBase+i)%360;
        const ethFactor = Math.min(ethBalance/10,1); hue=(hue+ethFactor*100)%360;
        const speed=0.005+0.01*(hashStringToInt((t.symbol||t.address)+seedBase+i,10)/10);
        const r=t.isNFT?10:2+6*balanceFactor;
        const angle=seededRandomFloat(seedBase+i+'angle')*2*Math.PI;
        const radius=50+seededRandomFloat(seedBase+i+'radius')*400;
        initialParticles.push({angle,radius,r,hue,speed,token:t});
      }
    }
    function cloneParticles(){ return initialParticles.map(p=>({...p})); }

    // ====== Drawing (kept behavior) ======
    function drawFrame(frame,showTokensFrame){
      const dpr = window.devicePixelRatio || 1;
      const scale = isMobile ? 0.6 : 1;
      const W = canvas.width/(dpr*scale);
      const H = canvas.height/(dpr*scale);
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
      const cx0=W/2, cy0=H/2;

      for(let i=0;i<particles.length;i++){
        for(let j=i+1;j<particles.length;j++){
          const p1=particles[i], p2=particles[j];
          const x1=cx0+Math.cos(p1.angle)*p1.radius;
          const y1=cy0+Math.sin(p1.angle)*p1.radius;
          const x2=cx0+Math.cos(p2.angle)*p2.radius;
          const y2=cy0+Math.sin(p2.angle)*p2.radius;
          const dx=x1-x2, dy=y1-y2;
          const dist=Math.sqrt(dx*dx+dy*dy);
          if(dist<200){
            const avgBalance=(Math.min(p1.token.balance,20)+Math.min(p2.token.balance,20))/40;
            const alpha=0.2+0.4*avgBalance*(1-dist/200);
            ctx.lineWidth=1.5+2*avgBalance;
            const txFactor=Math.log(txCount+1)/10;
            const hue=(p1.hue+p2.hue)/2+frame*0.4*txFactor;
            ctx.strokeStyle=`hsla(${hue},100%,70%,${alpha})`;
            ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
          }
        }
      }

      particles.forEach(p=>{
        p.angle+=p.speed;
        const cx=cx0+Math.cos(p.angle)*p.radius;
        const cy=cy0+Math.sin(p.angle)*p.radius;
        const gradient=ctx.createRadialGradient(cx,cy,0,cx,cy,p.r*2.5);
        gradient.addColorStop(0,`hsla(${p.hue},100%,70%,1)`);
        gradient.addColorStop(0.5,`hsla(${p.hue+20},100%,60%,0.9)`);
        gradient.addColorStop(1,`hsla(${p.hue+40},100%,40%,0.5)`);
        ctx.fillStyle=gradient; ctx.beginPath(); ctx.arc(cx,cy,p.r,0,Math.PI*2); ctx.fill();
      });

      if(showTokensFrame && showInfo){
        ctx.fillStyle='#0ff';
        ctx.font='22px Inter, Arial, sans-serif';
        ctx.fillText(`SepoliaETH: ${ethBalance.toFixed(4)}`,10,80);
      }
    }

    // ====== Token UI (DOM-safe, no unsanitized innerHTML) ======
    function updateTokenListUI() {
      tokenListContent.innerHTML = ''; // empty safely; content appended as text nodes below
      if(!tokens || tokens.length===0){
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.setAttribute('colspan','2');
        td.style.color = '#777';
        td.textContent = 'No tokens';
        tr.appendChild(td);
        tokenListContent.appendChild(tr);
        return;
      }
      tokens.forEach(t=>{
        const tr = document.createElement('tr');
        const addrTd = document.createElement('td');
        addrTd.textContent = t.address || '';
        addrTd.title = t.address || '';
        const balTd = document.createElement('td');
        balTd.textContent = (typeof t.balance === 'number') ? t.balance.toFixed(4) : String(t.balance);
        tr.appendChild(addrTd);
        tr.appendChild(balTd);
        tokenListContent.appendChild(tr);
      });
    }

    // ====== Wallet / Token / NFT fetching (saudzīga validācija) ======
    async function checkNFTAccess(){
      if(!account) return false;
      showProgressSmooth();
      try{
        const res = await fetch(`/api/getNFTs?account=${encodeURIComponent(account)}`, { cache: 'no-store' });
        if(!res.ok) return false;
        const data = await safeJson(res);
        return data?.ownsNFT === true;
      }catch(err){
        console.error(err);
        return false;
      }finally{ hideProgressSmooth(); }
    }

    async function getTokens(){
      if(!account) return [];
      showProgressSmooth();
      try{
        const res = await fetch(`/api/getTokens?account=${encodeURIComponent(account)}`, { cache: 'no-store' });
        if(!res.ok){ setStatus('Token API unavailable — fallback', true); return []; }
        const data = await safeJson(res);
        const rawBalances = data?.result?.tokenBalances || [];
        return rawBalances.map(t=>{
          const decimals = Number.isFinite(Number(t.tokenDecimals)) ? Number(t.tokenDecimals) : 18;
          const balanceHex = t.tokenBalance || t.balance || "0x0";
          let balance = 0;
          try{ balance = Number(ethers.formatUnits(balanceHex, decimals)); }catch(e){ balance = 0; }
          const address = (t.tokenAddress || t.contractAddress || '').toLowerCase();
          return { address, balance, symbol: t.symbol || address };
        }).filter(t=>t.balance>0);
      }catch(e){
        console.error(e);
        setStatus('Failed fetching tokens', true);
        return [];
      }finally{ hideProgressSmooth(); }
    }

    async function getAllNFTs(){
      if(!account) return [];
      showProgressSmooth();
      try{
        const res = await fetch(`/api/getAllNFTs?account=${encodeURIComponent(account)}`, { cache: 'no-store' });
        if(!res.ok) return [];
        const data = await safeJson(res);
        const nfts = data?.nfts || [];
        return nfts.map(nft => ({
          address: nft.contract?.address || '',
          symbol: nft.contract?.symbol || 'NFT',
          balance: 1,
          isNFT: true,
          tokenId: nft?.id?.tokenId
        }));
      }catch(e){
        console.error(e);
        return [];
      }finally{ hideProgressSmooth(); }
    }

    // ====== Connect Wallet ======
    async function connectWallet(){
      showProgressSmooth();
      try{
        // warn if provider RPC URL is a placeholder
        if(providerRpcUrl.includes('YOUR_ALCHEMY_KEY')){
          setStatus('Provider not configured (missing Alchemy key). WalletConnect may not work.', true);
          showToast('Warning: provider RPC URL not configured (alchemy key missing).');
        }

        if(window.ethereum){
          provider = new ethers.BrowserProvider(window.ethereum, "sepolia");
          await provider.send("eth_requestAccounts", []);
          signer = await provider.getSigner();
          account = await signer.getAddress();
        } else {
          // WalletConnect fallback
          try{
            wcProvider = new WalletConnectProvider.default({ rpc: { 11155111: providerRpcUrl } });
            await wcProvider.enable();
            provider = new ethers.BrowserProvider(wcProvider, "sepolia");
            signer = await provider.getSigner();
            account = await signer.getAddress();
          }catch(e){
            console.error('WalletConnect failed', e);
            setStatus('WalletConnect failed or not configured.', true);
            hideProgressSmooth();
            return;
          }
        }

        accountDisplay.textContent = 'Connected account: ' + account;
        walletSeed = hashStringToInt(account);

        const hasNFT = await checkNFTAccess();
        if(hasNFT){
          renderBtn.disabled = false; renderBtn.removeAttribute('aria-disabled');
          recordBtn.disabled = false; recordBtn.removeAttribute('aria-disabled');
          setStatus('Wallet connected & NFT verified — access granted.');
        } else {
          renderBtn.disabled = true; renderBtn.setAttribute('aria-disabled','true');
          recordBtn.disabled = true; recordBtn.setAttribute('aria-disabled','true');
          setStatus('NFT not found — access denied.', true);
          showToast('Access denied — required NFT not found.');
        }
      }catch(err){
        console.error(err);
        setStatus('Wallet connection failed.', true);
        showToast('Wallet connection failed. Check console.');
      }finally{ hideProgressSmooth(); }
    }

    // ====== Render Snapshot ======
    async function renderSnapshot(){
      if(!account) await connectWallet();
      if(!provider || !account){ setStatus('Wallet not connected.', true); return; }

      stopAnimation();
      showProgressSmooth();
      progressBar.style.transform='scaleX(0)';
      setStatus('');

      const steps=[
        {name:'Fetching ETH balance', func: async()=>{ ethBalance=Number(ethers.formatEther(await provider.getBalance(account)))||0; }},
        {name:'Fetching transaction count', func: async()=>{ txCount=Number(await provider.getTransactionCount(account))||0; }},
        {name:'Fetching tokens', func: async()=>{ tokens=[...await getTokens()]; }},
        {name:'Fetching NFTs', func: async()=>{ tokens=[...tokens,...await getAllNFTs()]; }},
        {name:'Initializing particles', func: async()=>{ await initParticlesOnce(); particles=cloneParticles(); }}
      ];

      let currentStep=0, totalSteps=steps.length;
      let visualProgress=0, running=true;

      function animateProgress(){
        if(!running) return;
        const targetProgress=currentStep/totalSteps;
        visualProgress+=(targetProgress-visualProgress)*0.05;
        progressBar.style.transform=`scaleX(${visualProgress})`;
        progressBar.setAttribute('aria-valuenow', String(visualProgress.toFixed(2)));
        requestAnimationFrame(animateProgress);
      }
      requestAnimationFrame(animateProgress);

      try{
        for(const step of steps){
          setStatus(step.name + '...');
          await step.func();
          currentStep++;
        }

        if(showInfo){ tokenListContainer.style.display='block'; tokenListContainer.setAttribute('aria-hidden','false'); updateTokenListUI(); }

        running=false; progressBar.style.transform='scaleX(1)'; setStatus('Visualization running!');
        hideProgressSmooth();
        animate();
      }catch(e){
        running=false; hideProgressSmooth(); console.error(e); setStatus('Error rendering visualization.', true); showToast('Render failed. Check console.');
      }
    }

    // ====== Animation loop ======
    function animate(frame=0){ drawFrame(frame,true); animRequest = requestAnimationFrame(()=>animate(frame+1)); }
    function stopAnimation(){ if(animRequest) cancelAnimationFrame(animRequest); animRequest=null; }

    // ====== Keyboard & UI handlers ======
    connectBtn.addEventListener('click', connectWallet);
    renderBtn.addEventListener('click', renderSnapshot);
    fullscreenIcon.addEventListener('click', ()=>{ if(!document.fullscreenElement) canvas.requestFullscreen().catch(()=>{}); else document.exitFullscreen().catch(()=>{}); });
    fullscreenIcon.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); fullscreenIcon.click(); } });

    toggleInfoIcon.addEventListener('click', ()=>{
      showInfo = !showInfo;
      document.getElementById('infoText').textContent = showInfo ? 'Info' : 'Hidden';
      toggleInfoIcon.setAttribute('aria-pressed', String(showInfo));
      tokenListContainer.style.display = showInfo ? 'block' : 'none';
      tokenListContainer.setAttribute('aria-hidden', showInfo ? 'false' : 'true');
      if(showInfo) updateTokenListUI();
    });

    // ====== MediaRecorder support detection & helpers ======
    function pickSupportedMimeType(){
      const candidates=['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
      for(const c of candidates){
        try{ if(MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) return c; }catch(e){}
      }
      return '';
    }

    // If the browser does not support MediaRecorder with a known mime, disable record button
    (function checkRecordingSupport(){
      const mime = pickSupportedMimeType();
      if(!mime){
        // attempt to see if MediaRecorder exists at all
        if(typeof MediaRecorder === 'undefined'){
          recordBtn.disabled = true;
          recordBtn.setAttribute('aria-disabled','true');
          setStatus('Recording not supported in this browser.', true);
        } else {
          // MediaRecorder exists but no known mime supported
          setStatus('No supported video codec available for recording in this browser.', true);
          showToast('Recording not supported (no known codec).');
          recordBtn.disabled = true;
          recordBtn.setAttribute('aria-disabled','true');
        }
      }
    })();

    // ====== Recording (with safer UX & cleanup) ======
    async function startRecording(includeTokens=false){
      if(startRecording._recording) return;
      startRecording._recording = true;
      const previousShowInfo = showInfo;

      // Show tokens on canvas if requested
      showInfo = false;
      if(includeTokens){ tokenListContainer.style.display = 'block'; document.getElementById('infoText').textContent = 'Info'; }

      stopAnimation();
      particles = cloneParticles();
      drawFrame(0,true);
      setStatus('Preparing recording...');
      recordBtn.disabled = true; renderBtn.disabled = true; connectBtn.disabled = true;
      showProgressSmooth(); if(!animRequest) animate();

      let stream;
      try{ stream = canvas.captureStream(30); } catch(err){
        setStatus('Recording not supported (captureStream failed).', true);
        cleanupAfterRecording();
        return;
      }

      const mime = pickSupportedMimeType();
      if(!mime){
        setStatus('No supported recording mime type available.', true);
        cleanupAfterRecording();
        return;
      }

      let recorder;
      try{ recorder = new MediaRecorder(stream, { mimeType: mime }); }catch(err){
        console.error('MediaRecorder init failed', err);
        setStatus('MediaRecorder not available.', true);
        cleanupAfterRecording();
        return;
      }

      const chunks = [];
      recorder.ondataavailable = (e) => { if(e.data && e.data.size) chunks.push(e.data); };
      recorder.onerror = (ev) => { console.error(ev); setStatus('Recording error.', true); };
      recorder.onstart = () => { setStatus('Recording...'); };

      try{ recorder.start(); }catch(e){ console.error(e); setStatus('Failed to start recorder.', true); cleanupAfterRecording(); return; }

      const startTime = performance.now(), duration = 20000;
      function updateProgress(timestamp){
        const elapsed = timestamp - startTime;
        const progress = Math.min(elapsed/duration, 1);
        progressBar.style.transform = `scaleX(${progress})`;
        progressBar.setAttribute('aria-valuenow', String(progress.toFixed(2)));
        const seconds = Math.floor(elapsed/1000);
        recordTimer.textContent = `Recording: ${seconds} / 20 s`;
        if(elapsed < duration) requestAnimationFrame(updateProgress);
        else try{ recorder.stop(); }catch(e){}
      }
      requestAnimationFrame(updateProgress);

      recorder.onstop = () => {
        try{
          const blob = new Blob(chunks, { type: chunks.length ? chunks[0].type : mime });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.style.display='none'; a.href = url;
          const ext = blob.type.includes('mp4') ? 'mp4' : 'webm';
          a.download = `wallet_visualization.${ext}`; document.body.appendChild(a); a.click();
          setTimeout(()=>{ document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
          setStatus('Recording finished!');
          showToast('Recording finished and downloaded.');
        }catch(e){
          console.error('Saving recording failed', e);
          setStatus('Saving recording failed.', true);
        } finally {
          cleanupAfterRecording();
        }
      };

      function cleanupAfterRecording(){
        try{ if(recorder && recorder.state === 'recording') recorder.stop(); }catch(e){}
        showInfo = previousShowInfo;
        document.getElementById('infoText').textContent = showInfo ? 'Info' : 'Hidden';
        tokenListContainer.style.display = showInfo ? 'block' : 'none';
        tokenListContainer.setAttribute('aria-hidden', showInfo ? 'false' : 'true');
        updateTokenListUI();
        recordBtn.disabled = false; renderBtn.disabled = false; connectBtn.disabled = false;
        hideProgressSmooth(); recordTimer.textContent = 'Recording: 0 / 20 s';
        startRecording._recording = false;
      }
    }

    // Basic cleanup function for early exits
    function cleanupAfterRecording(){
      showInfo = true;
      tokenListContainer.style.display = 'block';
      tokenListContainer.setAttribute('aria-hidden', 'false');
      updateTokenListUI();
      recordBtn.disabled = false; renderBtn.disabled = false; connectBtn.disabled = false;
      hideProgressSmooth(); recordTimer.textContent = 'Recording: 0 / 20 s';
      startRecording._recording = false;
    }

    // Wire record button to open dialog with focus trap
    recordBtn.addEventListener('click', openRecordDialog);

    recordWithTokensBtn.addEventListener('click', ()=>{ closeRecordDialog(); startRecording(true); });
    recordWithoutTokensBtn.addEventListener('click', ()=>{ closeRecordDialog(); startRecording(false); });

    dropdownClose.addEventListener('click', closeRecordDialog);
    overlay.addEventListener('click', closeRecordDialog);

    // ====== Dialog open/close with focus trap & accessibility ======
    function openRecordDialog(){
      if(recordBtn.disabled) return;
      overlay.style.display = 'block';
      overlay.setAttribute('aria-hidden','false');
      recordDropdown.style.display = 'block';
      recordDropdown.setAttribute('aria-hidden','false');
      recordBtn.setAttribute('aria-expanded','true');
      document.body.style.overflow = 'hidden';
      // Focus first interactive element in dialog
      const focusable = getFocusableElements(recordDropdown);
      if(focusable.length) focusable[0].focus();

      // key handler for trap + escape
      function handleKey(e){
        if(e.key === 'Escape'){ e.preventDefault(); closeRecordDialog(); return; }
        if(e.key === 'Tab' && focusable.length){
          const idx = focusable.indexOf(document.activeElement);
          if(e.shiftKey && idx === 0){ e.preventDefault(); focusable[focusable.length-1].focus(); }
          else if(!e.shiftKey && idx === focusable.length-1){ e.preventDefault(); focusable[0].focus(); }
        }
      }
      recordDropdown._keyHandler = handleKey;
      document.addEventListener('keydown', handleKey);
    }

    function closeRecordDialog(){
      overlay.style.display = 'none';
      overlay.setAttribute('aria-hidden','true');
      recordDropdown.style.display = 'none';
      recordDropdown.setAttribute('aria-hidden','true');
      recordBtn.setAttribute('aria-expanded','false');
      document.body.style.overflow = '';
      if(recordDropdown._keyHandler) document.removeEventListener('keydown', recordDropdown._keyHandler);
      // return focus to the record button
      recordBtn.focus();
    }

    function getFocusableElements(container){
      const selectors = 'a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])';
      return Array.from(container.querySelectorAll(selectors)).filter(el => el.offsetParent !== null);
    }

    // also allow enter-space activation for icons
    toggleInfoIcon.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); toggleInfoIcon.click(); } });

    // ====== Init: small status ======
    setStatus('Ready. Connect wallet to begin.');

    // ====== Optional: cleanup on unload ======
    window.addEventListener('beforeunload', ()=>{ try{ if(wcProvider && wcProvider.disconnect) wcProvider.disconnect(); }catch{} });
  </script>
</body>
</html>
























